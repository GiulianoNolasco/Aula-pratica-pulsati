CREATE TABLE giu_usuarios (
    id              NUMBER PRIMARY KEY,
    cpf             VARCHAR2(15) NOT NULL UNIQUE,
    sexo            VARCHAR2(1) NOT NULL,
    nome            VARCHAR2(4000) NOT NULL,
    data_nascimento DATE,
    tipo_sanguineo  VARCHAR2(3)
);

ALTER TABLE GIU_USUARIOS MODIFY DATA_NASCIMENTO DATE NOT NULL;

ALTER TABLE GIU_USUARIOS ADD sobrenome VARCHAR2(4000) NOT NULL;


ALTER TABLE GIU_USUARIOS drop column sobrenome ;


COMMENT ON COLUMN GIU_USUARIOS.TIPO_SANGUINEO IS 'TIPO SANGUINEO'  ;

SELECT TO_CHAR(sysdate, 'DD/MM/YYYY HH24:MI:SS') FROM dual;  

SELECT TO_DATE('04/12/2001', 'DD/MM/YYYY') FROM dual;

SELECT DISTINCT 8 FROM GIULIANO_USUARIO

BETWEEN
WHERE



SELECT * FROM GIU_USUARIOS WHERE NOME LIKE '%a%'

and, varios selects

#########################################################################################################################
#########################################################################################################################
#########################################################################################################################



EX 01
Faça um select (query) que traga todos os dados das pessoas
SELECT * FROM giu_usuarios;

Ex 02
Faça um select (query) que traga somente o nome e a data de nascimento das pessoas
SELECT NOME,DATA_NASCIMENTO FROM GIU_USUARIOS

Ex 03
Faça um select (Query) que traga somente as pessoas aonde o email contenha '@gmail.com'
SELECT * FROM GIU_USUARIOS WHERE EMAIL LIKE'%@gmail%';

Ex 04
Faça um select (Query) que traga somente as pessoas onde o nome seja PEME
SELECT * FROM GIU_USUARIOS WHERE nome LIKE '%PEME%';

Ex 05
Faça um select (Query) que traga somente as pessoas nascidas depois dos anos 2015
SELECT * FROM GIU_USUARIOS WHERE data_nascimento BETWEEN TO_DATE('01/01/2015', 'DD/MM/YYYY') AND TO_DATE('04/12/2100', 'DD/MM/YYYY');

Ex 06
Faça um select (Query) que traga somente as pessoas nascidas antes dos anos 2015
SELECT * FROM GIU_USUARIOS WHERE data_nascimento BETWEEN TO_DATE('01/01/1900', 'DD/MM/YYYY') AND TO_DATE('01/01/2015', 'DD/MM/YYYY');

Ex 07
Faça um select (Query) que traga todas as pessoas onde nasceram no dia 12/12/2000 OU o nome contenha M em qualquer lugar da palavra
SELECT * FROM GIU_USUARIOS WHERE data_nascimento LIKE TO_DATE('04/12/2013', 'DD/MM/YYYY') OR NOME LIKE '%M%';


Ex 08
Faça um select (Query) que traga a pessoa que tenha um id igual a 33
SELECT * FROM GIU_USUARIOS WHERE ID LIKE 33;

SELECT
    gp.data_cadastro
FROM
         giu_vendas gv
    INNER JOIN giu_cliente gc ON gv.fk_id_cliente = gc.id_cliente
    INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto
    
    WHERE gp.data_cadastro < TO_DATE('04/12/2015', 'DD/MM/YYYY')


Ex 09
Faça um select (Query) onde traga o id e a data de nascimento das pessoas onde o nome termine com O OU o email da pessoa contenha @outlook.com ou a data de nascimento esteja em 10/07/1987 ou 26/07/2022
SELECT ID,DATA_NASCIMENTO FROM GIU_USUARIOS WHERE nome LIKE '%O' OR EMAIL LIKE '%@outlook.com%';

Ex 10
Faça um select (Query) onde traga o email das pessoas que terminem com I
SELECT * FROM GIU_USUARIOS WHERE EMAIL LIKE '%I@%';

Ex 11
Faça um select (Query) onde traga qual a maior data de nascimento onde o email contenha @hotmail.com
SELECT MIN(DATA_NASCIMENTO) FROM GIU_USUARIOS WHERE EMAIL LIKE '%@outlook.com%';

Ex 12
Faça um select (Query) onde traga a menor data de nascimento onde o email contenha @outlook.com
SELECT MIN(DATA_NASCIMENTO) FROM GIU_USUARIOS WHERE EMAIL LIKE '%@outlook.com%';


Ex 13
Faça um select (Query) onde traga a idade da pessoa, data de hoje menos a data de nascimento DATEDIFF(day, nascimento, hoje) /365
SELECT nome,TRUNC((SYSDATE - DATA_NASCIMENTO) /365) as IDADE from GIU_USUARIOS;


#########################################################################################################################
#########################################################################################################################
#########################################################################################################################



Crie uma tabela chamada NOME_DE_VOCES_funcionarios  A tabela deverá conter os seguintes campos
 id, primeiro_nome, segundo_nome, data_nascimento, cpf, rg, endereço, CEP, cidade, telefone, funcao, salario Insira uns 30 registros para base de dados



CREATE TABLE giu_funcionarios(
    id              NUMBER PRIMARY KEY,
    primeiro_nome   VARCHAR2(4000) NOT NULL,
    segundo_nome    VARCHAR2(4000) NOT NULL,
    data_nascimento DATE,
    cpf             VARCHAR2(15) NOT NULL UNIQUE,
    rg              VARCHAR2(15),
    endereco        VARCHAR2(100),
    cep             NUMBER(8),
    cidade          VARCHAR2(100),
    telefone        NUMBER(12),
    funcao          VARCHAR2(4000),
    salario         DECIMAL(100, 2)
    );
    

 INSERT INTO giu_funcionarios(id, primeiro_nome, segundo_nome, data_nascimento, cpf, rg, endereço, cep, cidade, telefone, funcao, salario) 
                      VALUES ('1','TESTE','TESTADO','05/05/2000','047.657.985-88','5004595','RUA NAO LOCALIZADA','89023300','GASPAR','04799998888','TRABALHADOR','2000,00');

                      INSERT INTO giu_funcionarios (
    id,
    primeiro_nome,
    segundo_nome,
    data_nascimento,
    cpf,
    rg,
   endereco,
    cep,
    cidade,
    telefone,
    funcao,
    salario
) VALUES (
    '14',
    'TESTE',
    'TESTE',
    '14/05/1877',
    '006.193.949-13',
    '47859951',
    'RUA DOS EX PRESIDENTES',
    '89014777',
    'SAO PAULO',
    '04789747889',
    'PRESIDENTE',
    '220000,00'
);
1 Crie um select que traga todas as pessoas que começem com a letra A ou contenha no meio a letra J ou termine com I|
SELECT * FROM GIU_FUNCIONARIOS WHERE (PRIMEIRO_NOME LIKE 'A%' OR  PRIMEIRO_NOME LIKE '%J%' OR PRIMEIRO_NOME LIKE 'I%');

2 Crie um select que traga todas as pessoas que nasceram antes de 1999
SELECT * FROM GIU_FUNCIONARIOS WHERE (DATA_NASCIMENTO < TO_DATE('01/01/1999', 'DD/MM/YYYY'));

3 Crie um select em que o rg da pessoa seja diferente de 123.456.789-01
SELECT * FROM GIU_FUNCIONARIOS WHERE (RG!=5004595);

4 Crie um select que traga quais cidades existem na base de dados porém sem repetir 
SELECT DISTINCT CIDADE FROM GIU_FUNCIONARIOS ;

5 Crie um select que traga quais pessoas existem na base de dados porém sem repetir
SELECT DISTINCT PRIMEIRO_NOME FROM GIU_FUNCIONARIOS ;

6 Crie um select onde você traga o nome e o sobrenome concatenados em uma coluna de todas as pessoas com mais de 20 anos ou que o telefone termina com 9

SELECT PRIMEIRO_NOME || ' '||SEGUNDO_NOME as nome_completo, TRUNC((SYSDATE - data_nascimento) /365) AS IDADE, TELEFONE
FROM GIU_FUNCIONARIOS
WHERE TRUNC((SYSDATE - data_nascimento) /365) > 20 OR TELEFONE LIKE '9%';


7 Crie um select onde você traga todas as pessoas ordenadas pela função de trabalho 
SELECT * FROM GIU_FUNCIONARIOS ORDER BY FUNCAO

8 Crie um select onde você traga a média salarial agrupada por funcao
SELECT AVG(SALARIO)AS MEDIA_SALARIO,FUNCAO FROM GIU_FUNCIONARIOS GROUP BY FUNCAO

9 traga todos os registros com id entre 10 e 15
SELECT * FROM GIU_USUARIOS WHERE ID BETWEEN 5 AND 10;

10 selecione apenas os campos de id cpf, rg e traga somente os registros em que o o rg e o cpf nao começem com os digitos do id da linha.

SELECT ID,CPF,RG FROM GIU_FUNCIONARIOS 
WHERE (SUBSTR(RG,1,1) != ID) AND (SUBSTR(CPF,1,1) != ID);


#########################################################################################################################
#########################################################################################################################
#########################################################################################################################

Crie uma tabela chamada NOME_DE_VOCES_filmes
A tabela deverá conter os seguintes campos id, nome, descricao, data_lancamento, quantidade_vendas, pais_origem
Insira uns 30 registros para base de dados 

1 - Deverá trazer todos os filmes com vendas maiores que 100 e
que a descriçao contenha no meio da string "a" 

SELECT * FROM GIU_FILMES WHERE quantidade_vendas > 100 AND descricao like '%a%'


2 - Deverá trazer todos os filmes que o pais de origem seja Brasil ou que o nome do filme contenha Brasil
SELECT * FROM GIU_FILMES WHERE pais_origem LIKE '%Índia%' OR nome LIKE '%Roma%';



#########################################################################################################################
#########################################################################################################################
#########################################################################################################################



- MIN() => traz o menor registro - MAX() => traz o maior registro - AVG() => traz a média dos registros - SUM() => traz a soma dos registros - FLOOR => arredonda para abaixo - SEIL => arredonda para cima - ROUND => considera arredondar para onde estiver mais perto e tem como passar o parametro de quantas casas decimais você quer manter - REPLACE() => mudar um caracter por outro
É possível envolver em outro replace para substituir mais de uma coisa - SUBSTR() => para pegar apenas uma parte da string. Recebe parametro da posição de inicio e posição de fim. - LENGTH => diz quantos caracteres existe na sua string Update e Delete:
- UPDATE: atualiza algum/alguns campos - SEMPRE use o where
EX:
update tabela
set coluna = atualização
where = id - DELETE: deletea os registros - SEMPRE use o where
EX:
delete tabela
where = id Chaves Estrangeiras:
- Foreign Key => referencia do id de outra tabela Concetio de Join: Inner Join => traz apenas os registros que são iguais:
select u.nome, t.nr_telefone
from giu_usuarios u
inner join giu_telefone_usuarios t on t.id_usuario = u.id; Left Join => traz todos os registros da tabela da esquerda e os que existem na tabela da direita que são iguais, se não houver traz null.
select u.nome, t.nr_telefone
from giu_usuarios u
left join giu_telefone_usuarios t on t.id_usuario = u.id;
Right Join => 
select u.nome, t.nr_telefone
from giu_usuarios u
right join giu_telefone_usuarios t on t.id_usuario = u.id;


#########################################################################################################################
#########################################################################################################################
#########################################################################################################################
[09:54] Adriana Dias Brunner[09:54] Adriana Dias Brunner
--SOMA COM ALIAS (PODE TIRAR O AS) 
SELECT SUM(SALARIO) AS SALARIO FROM ADRI_FUNCIONARIOS
 
 -- AGREGAÇÃO + PUXAR OUTRA COLUNA 
SELECT SUM(SALARIO) AS SALARIO, FUNCAO FROM ADRI_FUNCIONARIOS GROUP BY FUNCAO 
 
--MEDIA + AGRUPAMENTO 
SELECT AVG(SALARIO) AS SALARIO, FUNCAO FROM ADRI_FUNCIONARIOS GROUP BY FUNCAO 
 
-- COUNT PARA CONTAR QUANTAS LINHAS DE REGISTRO EXISTE
SELECT COUNT(*) FROM TABELA WHERE CIDADE = 'SAO PAULO' 
 
--ARREDONDAMENTO 
SELECT CEIL(AVG(SALARIO)) AS SALARIO FROM ADRI_FUNCIONARIOS --PRA CIMA 
SELECT FLOOR(AVG(SALARIO)) AS SALARIO FROM ADRI_FUNCIONARIOS --PRA BAIXO 
SELECT ROUND(AVG(SALARIO), 2) AS SALARIO FROM ADRI_FUNCIONARIOS --DEFINE QUANTAS CASAS APÓS A VIRGULA
 
 --REPLACE - TIRAR PONTOS E TRAÇOS - UM PARAMETRO POR VEZ, POR ISSO USAR 2 REPLACE 
SELECT REPLACE(REPLACE(CPF, '-',''),'.','') FROM ADRI_FUNCIONARIOS 
 
-- SUBSTR PARA CORTAR PALAVRAS EX MARIA RETORNA MARI 
SELECT SUBSTR(PRIMEIRO_NOME, 0,4) FROM ADRI_FUNCIONARIOS WHERE ID = 11
 
-- LENGTH PARA CONTAR O TAMANHO 
SELECT LENGTH(PRIMEIRO_NOME) FROM ADRI_FUNCIONARIOS WHERE ID = 11 
 
--FOREIGN KEY 
CREATE TABLE ADRI_TELEFONES ( 
ID_TELEFONE NUMBER PRIMARY KEY,
NR_TELEFONE VARCHAR(10) NOT NULL, 
ID_USUARIO NUMBER, 
CONSTRAINT ID_USUARIO_ADRI_FK FOREIGN KEY (ID_USUARIO) REFERENCES ADRI_USUARIOS(ID) ) 
 
--JOIN 
 
SELECT NOME FROM ADRI_USUARIOS 
INNER JOIN ADRI_TELEFONES ON ADRI_TELEFONE.ID_USUARIOS = ADRI_USUARIOS.ID


#########################################################################################################################
#########################################################################################################################
#########################################################################################################################
Tabela PAISES:
 
PAIS_ID numero
NOME_PAIS texto nao nulo
 
 
Tabela ESTADOS
 
ESTADO_ID numero
NOME_ESTADO texto nao nulo
FK_ID_PAIS 
 
 CREATE TABLE giu_estados(
estado_id NUMBER PRIMARY KEY,
nome_estado VARCHAR2(500) NOT NULL,
fk_id_pais NUMBER,
CONSTRAINT id_pais_giu_fk FOREIGN KEY (fk_id_pais) REFERENCES giu_paises(pais_id)
);


 
Tabela Cidades
 
CIDADE_ID numero
NOME_CIDADE texto not nulo
FK_ID_ESTADO
 
CREATE TABLE giu_cidades(
cidade_id NUMBER PRIMARY KEY,
nome_cidade VARCHAR2(500) NOT NULL,
fk_id_estado NUMBER,
CONSTRAINT id_estado_giu_fk FOREIGN KEY (fk_id_estado) REFERENCES giu_estados(estado_id)
);


Tabela PESSOAS
 
PESSOA_ID numero
NOME_PESSOA texto
EMAIL_PESSOA texto
DATA_NASCIMENTO data nao nulo
FK_ID_CIDADE


CREATE TABLE giu_pessoas(
pessoa_id NUMBER PRIMARY KEY,
nome_pessoa VARCHAR2(500),
email_pessoa VARCHAR2(500),
data_nascimento date NOT NULL,
fk_id_cidade NUMBER,
CONSTRAINT id_cidade_giu_fk FOREIGN KEY (fk_id_cidade) REFERENCES giu_cidades(cidade_id)
);

 
Insira registros em todas as tabelas
 

 
 
## Ex01
`Fazer uma consulta (Query), onde traga o email da pessoa, e de qual Cidade essa pessoa pertence.`
 
SELECT
    gp.email_pessoa,
    gc.nome_cidade
FROM
         giu_pessoas  gp
    INNER JOIN giu_cidades gc ON  gc.cidade_id = gp.fk_id_cidade;






 
## Ex02
`Fazer uma consulta (Query), onde traga quantas pessoas estão cadastradas em cada pais`
 
SELECT
     gp.nome_pais, COUNT(gpe.pessoa_id) as soma
FROM
    giu_paises gp
INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
GROUP BY gp.nome_pais;





## Ex03
`Fazer um consulta (Query), onde traga quantas pessoas estão cadastradas em cada cidade`
 
SELECT
     gc.nome_cidade, COUNT(gpe.pessoa_id) as soma
FROM
    giu_cidades gc
INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
GROUP BY  gc.nome_cidade;





## Ex04
`Fazer uma consulta (Query), onde traga quantas pessoas estão cadastradas em cada estado`

SELECT
ge.nome_estado, COUNT(gpe.pessoa_id) as soma
FROM giu_estados ge
INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
GROUP BY ge.nome_estado;
 





## Ex05
`Fazer uma consulta (Query), onde traga qual é o nome e o código dos paises cadastrados.`
 
SELECT
    giu_paises.nome_pais, giu_paises.pais_id
FROM
    giu_paises ;






## Ex06
`Fazer uma consulta (Query), onde traga todas as pessoas que moram no pais com Id 3 e que nasceram depois do dia 01/01/2000 e que o email contenha @gmail.com`
 
SELECT
     gpe.nome_pessoa,gpe.data_nascimento,gpe.email_pessoa, gp.nome_pais,gp.pais_id
FROM
    giu_paises gp
INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
WHERE (gpe.data_nascimento > TO_DATE('01/01/2000', 'DD/MM/YYYY')) 
AND (gpe.email_pessoa LIKE '%@gmail.com%');
 
 
## Ex07
`Fazer uma consulta (Query), onde traga a pessoa mais velha do pais com id 1`
 
SELECT MAX(idade) FROM (
    SELECT
        gpe.nome_pessoa,
        trunc((sysdate - gpe.data_nascimento) / 365) AS idade,
        gp.nome_pais,
        gp.pais_id
    FROM
             giu_paises gp
        INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
        INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
        INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
    WHERE
        gp.pais_id = 3
);

 ouuuuuuuuuuuuuuuuuuuu
adri fez 
SELECT data_nascimento, nome_pessoa from ADRI_pessoas 
where data_nascimento = (SELECT min(data_nascimento) 
from ADRI_PAISES INNER JOIN adri_estados ON adri_estados.id_pais = adri_paises.pais_id 
INNER JOIN adri_cidades ON adri_cidades.id_estado = adri_estados.estado_id 
INNER JOIN adri_pessoas ON adri_pessoas.id_cidade = adri_cidades.cidade_id
 WHERE (ID_PAIS = 1))

## Ex08
`Fazer uma consulta (Query), onde traga o nome e o email pessoa mais nova do estado Rio grande do sul`

SELECT gpe.nome_pessoa, gpe.email_pessoa,gpe.data_nascimento,ge.nome_estado FROM giu_pessoas gpe 

INNER JOIN giu_cidades gc ON gpe.fk_id_cidade = gc.cidade_id
INNER JOIN giu_estados ge ON gc.fk_id_estado = ge.estado_id

WHERE  (data_nascimento = (SELECT MAX(data_nascimento) FROM giu_pessoas gpe

INNER JOIN giu_cidades gc ON gpe.fk_id_cidade = gc.cidade_id
INNER JOIN giu_estados ge ON gc.fk_id_estado = ge.estado_id

WHERE (ge.nome_estado LIKE '% Sao Paulo %')));




 
## Ex09
`Fazer uma consulta (Query), onde traga o nome da pessoa, nome da cidade, nome do estado, e nome do pais das pessoas com mais de 30 anos UTILIZAR DATEDIFF NO WHERE`
 
SELECT
    gpe.nome_pessoa,
    TRUNC((SYSDATE - gpe.DATA_NASCIMENTO) /365),
    gc.nome_cidade,
    ge.nome_estado,
    gp.nome_pais
FROM
         giu_paises gp
    INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
    INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
    INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
WHERE
   TRUNC((SYSDATE - DATA_NASCIMENTO) /365)>30;
    
    
    


## Ex10
`Fazer uma consulta (Query), onde traga o nome da pessoa, nome da cidade, nome do estado, e nome do pais das pessoas com menos de 20 anos UTILIZAR DATEDIFF NO WHERE`
 
SELECT
    gpe.nome_pessoa,
    TRUNC((SYSDATE - gpe.DATA_NASCIMENTO) /365) as idade,
    gc.nome_cidade,
    ge.nome_estado,
    gp.nome_pais
FROM
         giu_paises gp
    INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
    INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
    INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
WHERE
   TRUNC((SYSDATE - DATA_NASCIMENTO) /365)<20;
    
    
    


## Ex11
 
`Fazer uma consulta (Query), onde traga o nome da pessoa, o email da pessoa, e o Estado que essa pessoa mora.`

SELECT
    ge.nome_estado,
    gpe.nome_pessoa,
    gpe.email_pessoa
FROM
         giu_estados ge
    INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
    INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id;
    

 
## Ex12
 
`Fazer uma consulta (Query), onde traga todas as pessoas que terminam com A no brasil`
 
SELECT
    gp.nome_pais, 
    gpe.nome_pessoa
FROM
         giu_paises gp
    INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
    INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
    INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
    WHERE (gpe.nome_pessoa LIKE '%A') AND (gp.nome_pais LIKE '%Brazil%');
 
## Ex13
 
`Fazer uma consulta (Query), onde traga a pessoa mais velha e a pessoa mais nova dentre todos os paises`
 
SELECT
    MAX(idade),
    MIN(idade)
FROM
    (
        SELECT
            gpe.nome_pessoa,
            trunc((sysdate - gpe.data_nascimento) / 365) AS idade,
            gp.nome_pais,
            gp.pais_id
        FROM
                 giu_paises gp
            INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
            INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
            INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
    );



## Ex14
 
`Fazer uma consulta (Query), onde traga as pessoas que nao forem de Santa catarina, Sao paulo e Texas`
 
SELECT
    gp.nome_pais,
    gpe.nome_pessoa,
    ge.nome_estado
FROM
         giu_paises gp
    INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
    INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
    INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
    WHERE ge.nome_estado != ' Cairo ' AND ge.nome_estado != ' Jining ' AND ge.nome_estado != ' Kuala Lumpur '
    
        
 
## Ex15
 
`Fazer uma consulta (Query), onde traga todas as pessoas do japão e que tenham mais de 35 anos`
 

SELECT
    gp.nome_pais,
    TRUNC((SYSDATE - gpe.data_nascimento) /365) as idade,
    gpe.nome_pessoa
FROM
         giu_paises gp
    INNER JOIN giu_estados ge ON ge.fk_id_pais = gp.pais_id
    INNER JOIN giu_cidades gc ON gc.fk_id_estado = ge.estado_id
    INNER JOIN giu_pessoas gpe ON gpe.fk_id_cidade = gc.cidade_id
    WHERE gp.nome_pais = ' Japan ' AND TRUNC((SYSDATE - gpe.data_nascimento) /365)>30;
        

 
## Ex16
 
`Fazer uma consulta (Query), onde traga quantas pessoas no japão tem o email do outlook.`
 
SELECT COUNT(*) FROM giu_pessoas gpe 

INNER JOIN giu_cidades gc ON gpe.fk_id_cidade = gc.cidade_id
INNER JOIN giu_estados ge ON gc.fk_id_estado = ge.estado_id
INNER JOIN giu_paises gp ON ge.fk_id_pais = gp.pais_id

WHERE gp.nome_pais LIKE '% Japan %';




#########################################################################################################################
#########################################################################################################################
#########################################################################################################################

 generated by defal as identid


dontpad.com
(come o +)


#########################################################################################################################
#########################################################################################################################
#########################################################################################################################

CREATE TABLE giu_produto (
    id_produto       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
    nome_produto      VARCHAR2(255) NOT NULL,
    descricao_produto VARCHAR2(4000) NOT NULL,
    codigo_produto    VARCHAR2(20) NOT NULL,
    data_cadastro     DATE DEFAULT sysdate
);

CREATE TABLE giu_cliente (
    id_cliente     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
    nome            VARCHAR2(255) NOT NULL,
    data_nascimento DATE NOT NULL,
    cpf             VARCHAR2(14) NOT NULL,
    cidade          VARCHAR2(20) NOT NULL
);

CREATE TABLE giu_vendas (
    id_venda      NUMBER
        GENERATED BY DEFAULT AS IDENTITY,
    data_venda    DATE DEFAULT sysdate,
    fk_id_cliente NUMBER,
    fk_id_produto NUMBER,
    CONSTRAINT giu_fk_id_cliente FOREIGN KEY ( fk_id_cliente )
        REFERENCES giu_cliente ( id_cliente ),
    CONSTRAINT giu_fk_id_produto FOREIGN KEY ( fk_id_produto )
        REFERENCES giu_produto ( id_produto )
);
[08:27] Johnny Blasius Seubert
criar essas tabelas, gerar uns 20 registros para cada uma delas

[08:28] Johnny Blasius Seubert
eu vou mostrar pra vcs como gerar o id automatico




1  Selecione todos os campos da tabela produto
SELECT * FROM giu_produto;



2  Selecione todos os campos da tabela cliente
SELECT * FROM giu_cliente;




3  Selecione todos os campos da tabela vendas
SELECT * FROM giu_vendas;



4  Selecione o nome e a descrição de todos os produtos
SELECT gp.nome_produto, gp.descricao_produto FROM giu_produto gp;




5  Selecione o nome, a data de nascimento e a cidade de todos os clientes
SELECT gc.nome, gc.data_nascimento, gc.cidade FROM giu_cliente gc;




6  Selecione a data da venda e o ID do cliente e do produto para todas as vendas
SELECT gv.data_venda,gv.fk_id_produto, gv.fk_id_cliente FROM giu_vendas gv;





7  Selecione o nome do cliente e o nome do produto para todas as vendas
SELECT
    gv.id_venda,
    gc.nome,
    gp.nome_produto
FROM
         giu_vendas gv
    INNER JOIN giu_cliente gc ON gv.fk_id_cliente = gc.id_cliente
    INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto;

    



8  Selecione a data de cadastro e a descrição de todos os produtos cadastrados antes de uma determinada data (vc escolhe)
SELECT
    gp.data_cadastro
FROM
         giu_vendas gv
    INNER JOIN giu_cliente gc ON gv.fk_id_cliente = gc.id_cliente
    INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto
    
    WHERE gp.data_cadastro < TO_DATE('04/12/2015', 'DD/MM/YYYY')




9  Selecione o nome do cliente e a data de nascimento de todos os clientes com idade superior a 30 anos
SELECT
    gc.nome, gc.data_nascimento,
    TRUNC((SYSDATE - DATA_NASCIMENTO) /365) as idade
FROM
         giu_vendas gv
    INNER JOIN giu_cliente gc ON gv.fk_id_cliente = gc.id_cliente
    INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto
    
    WHERE TRUNC((SYSDATE - gc.data_nascimento) /365) > 20






10  Selecione a quantidade de vendas realizadas em cada dia
SELECT
  gv.data_venda,
  COUNT(gv.data_venda) as quantidade_de_vendas
FROM
         giu_vendas gv
    INNER JOIN giu_cliente gc ON gv.fk_id_cliente = gc.id_cliente
    INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto
    
   GROUP BY gv.data_venda







11  Selecione o nome do produto e a soma dos preços de todas as vendas desse produto
SELECT
    gp.nome_produto,
    SUM(gp.preco) AS precovendas
FROM
         giu_produto gp
    INNER JOIN giu_vendas gv ON gv.fk_id_cliente = gp.id_produto
GROUP BY
    gp.nome_produto;






12  Selecione o nome do cliente e o nome do produto de todas as vendas.
SELECT
    gv.id_venda,gc.nome, gp.nome_produto
FROM
         giu_vendas gv
    INNER JOIN giu_cliente gc ON gv.fk_id_cliente = gc.id_cliente
    INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto;






13  Selecione o nome do cliente, a cidade e a data de nascimento de todos os clientes que compraram um produto.
SELECT
gc.id_cliente,
    gc.nome,
    gc.cidade,
    gc.data_nascimento
FROM
         giu_cliente gc
    INNER JOIN giu_vendas gv ON gv.fk_id_cliente = gc.id_cliente;
    



14  Selecione o nome do produto, a descrição do produto e a quantidade vendida de todos os produtos.

SELECT
    gp.nome_produto, gp.descricao_produto,
    COUNT(gv.fk_id_produto) AS qt_venda_por_produto    
FROM
         giu_produto gp
    INNER JOIN giu_vendas gv ON gv.fk_id_produto = gp.id_produto
GROUP BY
    gp.nome_produto,gp.descricao_produto;





15  Selecione o nome do cliente, a cidade e o total gasto em compras pelo cliente

SELECT gc.nome, gc.cidade, 
SUM(gp.preco) AS total_gasto_cliente
FROM
             giu_cliente gc
        INNER JOIN giu_vendas  gv ON gv.fk_id_cliente = gc.id_cliente
        INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto
GROUP BY
    gc.nome, gc.cidade;

16. Selecione a Quantidade de vendas por cliente 

SELECT
    gc.nome,
    COUNT(gv.id_venda) AS total_vendas_por_cliente
FROM
         giu_cliente gc
    INNER JOIN giu_vendas  gv ON gv.fk_id_cliente = gc.id_cliente
    INNER JOIN giu_produto gp ON gv.fk_id_produto = gp.id_produto
GROUP BY
    gc.nome;



17. Selecione quais clientes ja compraram alguma coisa

SELECT
    gc.nome
FROM
         giu_cliente gc
    INNER JOIN giu_vendas gv ON gv.fk_id_cliente = gc.id_cliente
    group BY gc.nome;



18. Selecione quais clientes nao compraram nada

SELECT
    gc.nome,gc.id_cliente
FROM
    giu_cliente gc
    LEFT JOIN giu_vendas gv ON gc.id_cliente = gv.fk_id_cliente WHERE    gv.fk_id_cliente IS NULL
GROUP BY
    gc.nome,gc.id_cliente;

19. Selecione qual o produto mais comprado e o menos comprado

    
SELECT
    nome_produto,
    COUNT(*) AS contador
FROM
         giu_vendas
    INNER JOIN giu_produto ON (giu_produto.id_produto = giu_vendas.fk_id_produto)
GROUP BY
    nome_produto
ORDER BY
    contador DESC,
    nome_produto DESC
OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY;




20. Selecione quais produtos foram comprados mais de 5 vezes 




-


#########################################################################################################################
#########################################################################################################################
#########################################################################################################################

PL SQL

#########################################################################################################################
#########################################################################################################################
#########################################################################################################################


[09:26] Bradley Mafra
DECLARE
 
w_nome VARCHAR(250) := 'Bradley';
w_idade NUMBER;
 
BEGIN
 
IF w_nome = 'Bradley' THEN
    DBMS_OUTPUT.PUT_LINE('O nome é' || w_nome);
    ELSIF w_nome = '' THEN
    DBMS_OUTPUT.PUT_LINE('O nome está vazio');
    ELSE
    DBMS_OUTPUT.PUT_LINE('Nãoo sei o nome');
    END IF;
END;
 

[09:30] Bradley Mafra
DECLARE
 
w_cpf VARCHAR(250) := '';
w_idade NUMBER;
 
BEGIN
 
    SELECT cpf 
    INTO w_cpf
    FROM bradley_usuario 
    WHERE id = 1;

    DBMS_OUTPUT.PUT_LINE('O cpf encontrado foi: '||w_cpf);
 
END;

[09:35] Bradley Mafra
DECLARE
 
w_cpf VARCHAR(250) := '';
w_nome VARCHAR(250) := '';
w_idade NUMBER;
 
BEGIN
 
    SELECT cpf, nome
    INTO w_cpf, w_nome
    FROM bradley_usuario 
    WHERE id = 1;

    DBMS_OUTPUT.PUT_LINE('O cpf encontrado foi: '||w_cpf||' E o nome é: '||w_nome);
 
END;
 

[09:49] Bradley Mafra
DECLARE
 
w_cpf bradley_usuario.cpf%type;
w_nome bradley_usuario.nome%type;
w_sexo varchar2(20);
 
BEGIN
 
    FOR R IN (SELECT * FROM bradley_usuario)LOOP

        SELECT
            CASE
                WHEN R.sexo = 'M' THEN 'Masculino'
                WHEN R.sexo = 'F' THEN 'Feminino'
                ELSE 'Não informado'
            END
        INTO w_sexo
        FROM dual;


        DBMS_OUTPUT.PUT_LINE('O nome da vez é' || R.nome);
        DBMS_OUTPUT.PUT_LINE('O sexo da pessoa é: ' || w_sexo);
    END LOOP;
END;
 

[10:16] Bradley Mafra
DECLARE
 
w_contagem NUMBER := 200;
 
BEGIN
 
    FOR indice IN 1..w_contagem LOOP
            DBMS_OUTPUT.PUT_LINE(indice);
    END LOOP;
 
END;



[11:14] Bradley Mafra
CREATE OR REPLACE PROCEDURE bradley_procedure(p_id IN NUMBER)
IS
w_salario bradley_funcionarios.salario%type := 0;
w_nome bradley_funcionarios.primeiro_nome%type;
BEGIN
 
    SELECT primeiro_nome, salario 
    INTO w_nome, w_salario
    FROM bradley_funcionarios
    WHERE id = p_id;

    IF w_salario <= 2000 THEN
        DBMS_OUTPUT.PUT_LINE('O salario era: '|| w_salario);
        w_salario := w_salario * 1.1;
        UPDATE bradley_funcionarios
            SET salario = w_salario
            WHERE id = p_id;
        DBMS_OUTPUT.PUT_LINE('O novo salario é: '|| w_salario);
            ELSE
            DBMS_OUTPUT.PUT_LINE('Não é possivel aumentar o salario');
        END IF;
 
END;
 
SELECT * FROM bradley_funcionarios

 



#########################################################################################################################
#########################################################################################################################
#########################################################################################################################



1  Escreva um bloco PL/SQL que exiba "Número par" se o número for par e "Número ímpar" se for ímpar.
 


2  Escreva um bloco PL/SQL que calcule e exiba a soma dos números pares entre 10 e 20.
DECLARE
    w_contagem NUMBER := 19;
    w_soma
number := 0;

BEGIN
    FOR indice IN 11..w_contagem LOOP
        IF MOD(indice, 2) = 0 THEN
            w_soma := w_soma + indice;
        END IF;
            dbms_output.put_line(w_soma);

    END LOOP;

    dbms_output.put_line(w_soma);
END;





3  Escreva um bloco PL/SQL que determine e exiba se um número é primo ou não.
DECLARE
    w_numero NUMBER := 88;
    w_quantidadeDivisores NUMBER:=0;

BEGIN

    FOR indice IN 1..w_numero LOOP
        IF MOD(w_numero, indice) = 0 THEN
            w_quantidadeDivisores := w_quantidadeDivisores + 1;
        END IF;

    END LOOP;

IF w_quantidadeDivisores !=2 THEN
    dbms_output.put_line(w_numero||' Não é um número primo');
    ELSE 
        dbms_output.put_line(w_numero||' é um número primo');
END IF;
END;




4  Escreva um bloco PL/SQL que calcule e exiba o fatorial de um número.
DECLARE
    w_numero            NUMBER := 10;
    w_resultadofatorial NUMBER;
    w_inicio            NUMBER;
    w_fim               NUMBER;
BEGIN
    w_resultadofatorial := (w_numero * ( w_numero - 1 ));
    w_inicio := ( w_numero - 1 );
    w_fim := (w_numero-2);
    
    FOR indice IN 1..w_fim LOOP
        w_resultadofatorial := w_resultadofatorial * indice;
    END LOOP;

    dbms_output.put_line('Resposta: ' || w_resultadofatorial);
END;




5  Escreva um bloco PL/SQL que calcule e exiba a soma dos números impares entre 1 e 100.
DECLARE
    w_contagem NUMBER := 99;
    w_soma
number := 0;

BEGIN
    FOR indice IN 1..w_contagem LOOP
    
        IF MOD(indice, 2) != 0 THEN
            w_soma := w_soma + indice;
                    dbms_output.put_line(indice);

        END IF;

    END LOOP;

    dbms_output.put_line(w_soma);
END;




6  Escreva um bloco PL/SQL que exiba a tabuada de um número.

DECLARE
    w_numero NUMBER := 5;
    w_resultado NUMBER;
BEGIN
    FOR indice IN 1..10 LOOP
    w_resultado := w_numero*indice;
    dbms_output.put_line(indice||' x '||w_numero|| ' = '|| w_resultado);

    END LOOP;

END;




7  Escreva um bloco PL/SQL que calcule e exiba a média de uma tabela de números inteiros.

DECLARE
    w_soma    NUMBER;
    w_media   NUMBER;
    w_tamanho NUMBER;
BEGIN
    SELECT
        COUNT(codigo_produto)
    INTO w_tamanho
    FROM
        giu_produto;

    SELECT
        SUM(codigo_produto)
    INTO w_soma
    FROM
        giu_produto;

    w_media:= (w_soma/ w_tamanho);
    dbms_output.put_line(w_media);
END;






8  Escreva um bloco PL/SQL que determine e exiba o maior número em uma tabela de números inteiros.
DECLARE
    w_maiorNumero    NUMBER;
BEGIN
   SELECT MAX(codigo_produto)INTO w_maiorNumero FROM giu_produto;

    dbms_output.put_line(w_maiorNumero);
END;





9  Escreva um bloco PL/SQL que determine e exiba o menor número em uma tabela de números inteiros.

DECLARE
    w_menorNumero  NUMBER;
BEGIN
   SELECT MIN(id) INTO w_menorNumero FROM giu_usuarios;

    dbms_output.put_line(w_menorNumero);
END;






10  Escreva um bloco PL/SQL que determine e exiba a quantidade de números pares e ímpares em uma tabela de números inteiros.

DECLARE
    w_somapar   NUMBER:=0;
    w_somaimpar NUMBER:=0;
BEGIN
    FOR r IN (
        SELECT
            id_produto
        FROM
            giu_produto
    ) LOOP
        IF MOD(r.id_produto, 2) != 0 THEN
            w_somaimpar := w_somaimpar + 1;
        ELSE
            w_somapar := w_somaimpar + 1;
        END IF;
    END LOOP;

    dbms_output.put_line( w_somapar|| w_somaimpar);
END;




11  Escreva um bloco PL/SQL que determine e exiba a quantidade de caracteres vogais e consoantes em uma string.
DECLARE
    w_somavogais       NUMBER := 0;
    w_somaconsoantes   NUMBER := 0;
    w_string           VARCHAR2(100);
    w_letraselecionada VARCHAR2(100);
BEGIN
    
        SELECT
            nome_produto
        INTO w_string
        FROM
            giu_produto
        WHERE
            id_produto = 21;
   
   FOR indice IN 1..LENGTH(w_string) LOOP
        w_letraselecionada := substr(w_string, indice, 1);
        IF w_letraselecionada = 'A' OR w_letraselecionada = 'E'OR w_letraselecionada = 'I'OR w_letraselecionada = 'O'OR w_letraselecionada = 'U' THEN
            w_somavogais := w_somavogais + 1;
        ELSE
        w_somaconsoantes:= w_somaconsoantes+1;
        END IF;

    END LOOP;
    dbms_output.put_line(w_string);
    dbms_output.put_line('O total de vogais é: ' ||w_somavogais);
    dbms_output.put_line('O total de consoantes é: ' || w_somaconsoantes);

END;




12  Escreva um bloco PL/SQL que determine e exiba se um ano é bissexto ou não.

DECLARE
    w_ano NUMBER := 2023;
BEGIN
           
     IF (MOD(w_ano,4) = 0 AND MOD(w_ano,100)!=0) OR MOD(w_ano,400) = 0 THEN
   
    dbms_output.put_line('O ano é Bissexto');
        ELSE
    dbms_output.put_line('O ano NÃO é Bissexto');
        END IF;

END;



13  Escreva uma procedure PL/SQL que determine e exiba se uma string é palíndrome ou não.

CREATE OR REPLACE PROCEDURE giu_procedure_palindrome_giu_usuarios (
    p_id IN NUMBER
) IS
    w_nome        VARCHAR2(4000);
    w_nomereverse VARCHAR2(4000);
BEGIN
    SELECT
        nome
    INTO w_nome
    FROM
        giu_funcionarios
    WHERE
        id = p_id;

    w_nomereverse := reverse(w_nomereverse);
    IF w_nome = w_nomereverse THEN
        dbms_output.put_line(w_nomereverse || ' É uma palavra Palíndroma.');
    ELSE
        dbms_output.put_line(w_nomereverse || ' NÃO é uma palavra Palíndroma.');
    END IF;

END;


DECLARE
BEGIN
giu_procedure_palindrome_giu_usuarios(10);

END;







14  Escreva uma função PL/SQL que determine e retorne a quantidade de caracteres vogais em uma string específica.

create or replace NONEDITIONABLE FUNCTION quantidade_de_vogais(p_id IN NUMBER)
RETURN NUMBER

IS
    w_somavogais       NUMBER := 0;
    w_somaconsoantes   NUMBER := 0;
    w_string           VARCHAR2(100);
    w_letraselecionada VARCHAR2(100);

BEGIN

        SELECT
            NOME
        INTO w_string
        FROM
            giu_usuarios
        WHERE
            id = p_id;

   FOR indice IN 1..LENGTH(w_string) LOOP
        w_letraselecionada := substr(w_string, indice, 1);
        IF w_letraselecionada = 'A' OR w_letraselecionada = 'E'OR w_letraselecionada = 'I'OR w_letraselecionada = 'O'OR w_letraselecionada = 'U' THEN
            w_somavogais := w_somavogais + 1;
        ELSE
        w_somaconsoantes:= w_somaconsoantes+1;
        END IF;

    END LOOP;
    RETURN w_somavogais;

END;


SELECT quantidade_de_vogais(12) FROM giu_usuarios;



15  Escreva um procedimento PL/SQL que calcule e exiba a média de uma tabela de números específica.
16  Escreva um procedimento PL/SQL que determine e exiba o maior e menor número em uma tabela de números específica.
17  Escreva uma função PL/SQL que calcule e retorne a soma dos números pares entre dois números específicos.

